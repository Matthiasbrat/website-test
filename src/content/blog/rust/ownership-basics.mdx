---
title: "Rust Ownership Fundamentals"
description: "Understanding Rust's unique ownership system for memory safety without garbage collection."
date: 2024-03-10
---

import Callout from '@/components/mdx/Callout.astro';
import Aside from '@/components/mdx/Aside.astro';

# Rust Ownership Fundamentals

Ownership is Rust's most unique feature and enables memory safety guarantees without a garbage collector.

## The Three Rules

<Aside type="note" title="Ownership Rules">
1. Each value in Rust has a variable that's called its owner.
2. There can only be one owner at a time.
3. When the owner goes out of scope, the value will be dropped.
</Aside>

## Move Semantics

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // s1 is moved to s2

    // println!("{}", s1); // Error! s1 is no longer valid
    println!("{}", s2); // Works fine
}
```

## Borrowing

Instead of transferring ownership, you can borrow:

```rust
fn calculate_length(s: &String) -> usize {
    s.len()
}

fn main() {
    let s = String::from("hello");
    let len = calculate_length(&s);
    println!("Length of '{}' is {}", s, len);
}
```

<Callout type="tip">
Prefer borrowing over ownership transfer when the function doesn't need to own the data.
</Callout>

## Mutable References

```rust
fn main() {
    let mut s = String::from("hello");
    change(&mut s);
    println!("{}", s); // "hello, world"
}

fn change(s: &mut String) {
    s.push_str(", world");
}
```

<Callout type="warning">
You can only have one mutable reference to a value in a particular scope. This prevents data races at compile time.
</Callout>

## The Borrow Checker

The borrow checker ensures:
- No dangling references
- No data races
- References are always valid

```rust
// This won't compile - dangling reference
fn dangle() -> &String {
    let s = String::from("hello");
    &s // s goes out of scope, reference would be invalid
}

// This works - ownership is moved out
fn no_dangle() -> String {
    let s = String::from("hello");
    s
}
```

## Conclusion

Ownership might feel restrictive at first, but it catches entire categories of bugs at compile time that would be runtime errors in other languages.
